<!-- ---
title: 数据结构与算法精讲
description: 计算机科学基础核心课程，涵盖常用数据结构、算法设计与分析、复杂度分析等关键知识点
date: 2024-03-17
layout: default
parent: 打铁还需自身硬
nav_order: 2
tags:
  - 数据结构
  - 算法
  - 计算机基础
  - 编程基础
  - 算法分析
  - 编程实践
--- -->

[toc]
### 一、知识点总结 

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb51dgczj30u01ta44p.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}
注意：复杂度分析数据结构和算法学习的精髓

学习方法：

1、要从三个方面来思考，这个数据结构的来历，适合解决的问题以及应用场景

2、边学边练，适度刷题

3、多问多思考，多互动

4、打怪升级学习法，给自己设立一个切实可行的目标。

5、知识需要沉淀，不要试图一下子掌握所有

6、数据结构参考：[Go-datastruct](https://hub.fastgit.org/Workiva/go-datastructures.git)

### 二、数据结构与算法概念

1、数据结构：一组数据的存储结构

2、算法：操作数据的一组方法

3、数据结构与算法本质解决的是快和省的问题，让代码运行的更快，占用的空间更省

### 三、复杂度分析 

1、时间复杂度本质上是执行时间随数据规模增长变化的趋势

时间复杂度分析：

a、只关注执行次数最多的一段代码

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 } //时间复杂度为O(n)
```

b、加法法则，总复杂度等于量级最大的那段代码的复杂度

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) { // 复杂度为O(1)
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q; // 复杂度为o(n)
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j; // 复杂度为o(n^2)
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 } // 总复杂度为o(n^2)
```

c、嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i); // 复杂度为o(n)
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;//复杂度为o(n)
  } 
  return sum;
 }
// 总复杂度为o(n)*o(n) = o(n^2)
```

几种常见的复杂度

O(1)

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
 int i = 8;
 int j = 6;
 int sum = i + j;
```

O(n)

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
for (; i <= n; ++i) {
     sum = sum + i;
   }
```

O(n^2)

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j; // 复杂度为o(n^2)
     }
   }
```

O(logn) O(nlogn)

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
 i=1;
 while (i <= n)  {
   i = i * 3;  // 3^0  3^1 3^2  3^3  3^x=n   x=log3n
 }
```

O(m+n) O(m*n) 代码的复杂度有俩个数据规模决定

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i; // 复杂度为o(m)
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j; // 复杂度为o(n)
  }

  return sum_1 + sum_2;
} //总复杂度为o(m+n)
```

2、空间复杂度本质上是算法的存储空间随数据规模增长的变化趋势

常用的空间复杂度：O(1)、O(n)、O(n^2)

3、最好情况复杂度、最坏情况复杂度

最好情况复杂度就是在最理想的情况下执行这段代码的时间复杂度

最坏情况复杂度就是在最最糟糕的情况下执行这段代码的时间复杂度

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
} // 最好情况的复杂度为O(1) x位于数组的开头，所以遍历一遍
// 最坏情况的复杂度为o(n) x不在数组中所以要遍历真个数组
```

4、平均情况时间复杂度

平均情况时间复杂度也叫加权平均时间复杂度或者期望时间复杂度

以上例举例算法为：每种情况执行次数*这种情况出现的概率然后求和。

例如以上例为例的算法：

x在数组中的概率为1/2 不在数组中的概率为1/2
x在数组中每个位子的概率为1/n。

平均复杂度= 1*1/2n+2*1/2n+...+n*1/2n+n*1/2 = (3n+1)/4 = o(n)

5、均摊时间复杂度

使用场景：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况时间复杂度较高，而且这些操作之间存在前后连贯的时序关系。这个时候我们就可以使用均摊时间复杂度分析。看看能否将较高时间复杂度的那次操作耗时平摊到那些复杂度较低的操作上。

注意：一般均摊时间复杂度就等于最好情况下的复杂度

举例：

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
 // array 表示一个长度为 n 的数组
 // 代码中的 array.length 就等于 n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
// 最好的情况下复杂度为O(1)
// 最坏的情况下复杂度为O(n)
// 大多数情况下复杂度为o(1) 只有第n次复杂度为o(n) 而且是每次都是先进行n-1次复杂度为O(1)的操作，再进行o(n)的操作。因此可以将o(n)的操作耗时，分摊到n-1次o(1)的耗时上。这样得到的均摊复杂度为o(1)
```

6、递归的时间复杂度分析除了递推公式分析，也可以采用画递归树来分析

递归树：递归树的大致思想是算每一层的时间复杂度，然后乘以递归树的高度。

### 四：数组 

概念：数组是一种线性数据机构，它用一组连续的内存空间，来存储相同类型的数据

线性表：数组、链表、队列、栈

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb51o31tj30u00ma0u3.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

非线性表：树、堆、图

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb524utgj30tk0j4q3r.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

数组的特性：

-   随机访问
-   插入、删除操作比较低效（插入和删除会导致数据搬移）

数组编号为什么从0开始，而不是从1开始？

数组下标代表的是内存相对于首地址的偏移量，正常情况下对于数组第一个元素为a[0]，代表偏移0个位置。如

数组下标从1开始，那么第一个元素就必须为a[1-1]。这对于cpu来说就多了一次减指令。通过下标随机访问数组的

元素又是数组最基本的操作，效率必须优化到极致。因此数组编号是从0开始的而不是从1开始。

由数组原理引出的标记清除算法的核心思想

数组的删除操作一般需要数据的搬移，我们为了减少搬移的次数，可以在删除的时候先记录下已经删除的数据，

每次删除并不真正的删除。当数组没有更多的存储空间时，再出发一次真正的删除。

### 五、链表

1、LRU算法（缓存淘汰算法）

常见的缓存淘汰策略:

-   先进先出策略（FIFO）
-   最少使用策略（LFU）
-   最近最少使用策略（LRU算法)

基于链表来实现LRU（记得要用go语言实现）:

-   我们维护一个有序的单项链表，越靠近链表尾部的表示越早之前访问的。当有一个新的数据被访问时
-   如果数据已经被缓存到链表里了，我们遍历链表找到这个节点，然后从此位置删除这个节点并在链表开头从新插入该节点
-   如果数据未被缓存到链表里，当缓存未满时我们之间将节点插入到链表开头。如果缓存已满则删除链表尾部的节点并将该节点插入链表的开头。

基于数组实现LRU（有时间需补存完整）

2、链表的底层存储结构：通过指针将一组零散的内存块串联起来

3、三种常见的链表结构

a、单链表

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb533iktj30t808uq3h.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

b、双向链表

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb53ip83j30ro092mxk.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

适合应用在处理具有环形结构特点的数据(比如著名的约瑟夫问题-待研究）

c、循环链表

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb542bnjj30t209yq3i.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

相比于单向链表双向链表可以用o(1)的时间复杂度找到前驱节点，这在某些情况下的插入删除比单向链表更高

效。

4、链表的特点：

相较于数组而言，链表适合插入和删除，时间复杂度为o(1)。链表不适合随机访问，时间复杂度为o(n)

5、时空互换

对于耗时较多执行较慢的程序可以通过较多的消耗内存来进行优化（空间换时间），对于内存消耗较多的程序

可以通过降低执行速度来降低内存消耗（时间换空间）

6、链表和数组的比较

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb54ll84j30f809yjs0.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

-   数组实现上使用的是连续的存储空间，可以借助cpu的缓存机制，预读数组中的数据。所以访问效率会很高。而链表实现上使用的是不连续的存储空间，对cpu缓存不友好，所以没办法进行有效预读，访问效率不如数组高。
-   数组的缺点是大小固定，如果想要扩容，只能申请更大的内存空间将原有的数据拷过去。这样效率很低。而链表天然的支持动态扩容。
-   链表相较于数组每个节点除了存储数据之外还会多存储一份指向下一个节点的指针。因此对于内存苛刻的程序尽量选择数组。同时链表的插入和删除还会导致内存频繁的申请和释放，容易造成内存碎片。一些语言例如Go就有可能导致频繁的GC

7、如何正确的实现链表代码

-   利用哨兵简化实现难度（需要深入了解）
-   重点留意边界条件处理

### 六、栈

1、定义

只涉及一端插入删除数据，并且满足先进后出，后进先出的特性

2、栈可以用数组实现也可以用链表实现

3、栈只涉及俩个操作，入队和出队。时间复杂度均为o(1)

4、单调栈：在栈的基础上额外增加一个特性，从栈顶到栈底的元素是严格递增或递减的。

1）单调递增栈入栈：若当前进栈元素为e,
从栈顶开始遍历元素，把小于e或者等于e的元素弹栈，直到栈中数据大于e或者栈为空为止。然后再把e和弹出元素压栈。

2）单调递减栈入栈：每次弹出的元素是大于或者等于e的元素。

5、栈的应用：主要用在历史数据回溯

-   函数调用栈

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
int main() {
   int a = 1; 
   int ret = 0;
   int res = 0;
   ret = add(3, 5);
   res = a + ret;
   printf("%d", res);
   reuturn 0;
}

int add(int x, int y) {
   int sum = 0;
   sum = x + y;
   return sum;
}
```

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb555y42j30rs0ee750.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

以上函数的调用栈示意图

-   栈在表达式求值中的应用（编译器利用栈实现表达式求值）

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb55xcv1j30t40kwq4h.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

基本原理是：利用俩个栈，一个是操作数栈一个是运算符栈，然后从左至右的遍历表达式，遇到操作数就入操作

数栈，遇到运算符时，先和运算符栈的栈顶元素进行比较，如果优先级高于栈顶元素则将此运算符

入栈。如果优先级低于或等于栈顶元素则从操作数栈中取出俩个操作数进行计算，把计算结果入

栈，然后继续这一过程。

-   栈在括号匹配中的应用

例如：

假设[{()}]
这样左右匹配的表达式为合法的，[(})}这样的表达式为不合法的，我们怎么来检测表达式的合格与

否呢？

一般从左至右扫描表达式，当遇到左括号时将其压栈，当遇到右括号时则从栈中取出一个元素，如果和当前

右括号匹配则继续，如果不匹配或者栈中没有数据，则表达式为非法，当所有的括号都扫描完成后，栈中元

素为空则说明表达式合法，否则为非法

-   浏览器回退和前进

俩个栈实现前进和后退，分别是X和Y，我们将首次浏览过的页面都压入栈X，当点击回退时依次弹出栈，并依

次压入栈Y中，当点击前进时，再依次从Y中弹出元素

### 七、队列

1.  队列也是一种操作受限的线性数据结构，只有俩个操作，入队和出队。队列的特点是先进先出
2.  队列的应用：
3.  阻塞队列：当队列为空时出队方被阻塞，当队列满时入队被阻塞
4.  并发安全队列（加锁和无锁版）
5.  循环队列
6.  对于大部分资源有限的场景，当没有空闲资源时都可以用队列这种数据结构来实现请求排队

例如：线程池没有足够的线程来响应请求，这时就可以利用队列来对请求进行排队，但是设置合理的队列大小

非常重要，队列太大排队请求过多，请求处理的响应时间过长。队列太小导致无法充分利用系统资源。

4. 双端队列

本质还是队列，只不过是前端和后端都支持插入和删除。

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb56v2aqj310g08caaj.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

### 八、递归 

1.  满足递归的条件
2.  一个问题的解可以分解为几个子问题的解
3.  这个问题和分解之后的问题，除了规模不同外求解思路完全一样
4.  存在递归终止条件
5.  递归代码的关键就是大问题化小问题，找递推公式和终止条件
6.  编写递归代码的关键是，只要遇到递归，我们就把它抽象为一个递推公式，不用想一层一层的调用关系，不用试图用人脑去分解递归的每个步骤
7.  递归注意事项
8.  递归代码要警惕堆栈溢出。限制递归调用的最大深度可以解决，但也不是都能解决，因为递归深度和剩余的栈空间大小有关，而剩余栈空间是变化的。
9.  递归代码要警惕重复计算，比如n个台阶，每次可以走一个台阶或俩个台阶，n个台阶一共有多少中走法这个问题可以用递归的方式来求解。

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb57aig0j30pe0ly0ty.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

这个问题当中，如果n=6，递归展开如上图。可以看到其中f(3)
f(3)等调用了多次，这种问题可以用一个散

列表来存储已经计算过的值。当递归调用到f(k)时，先看看是否已经求解过。如果是直接从散列表中去值，

如果没有再计算代码如下：

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSovledList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSovledList.put(n, ret);
  return ret;
}
```

5. 怎样将递归改为迭代循环

递归的本质是利用系统的栈来实现的，所以可以手动用栈这个数据结构来实现迭代循环的非递归方式

### 九、排序算法

1.  排序算法分析
2.  排序算法的执行效率
3.  最好，最坏、平均时间复杂度
4.  时间复杂度的系数、常数、低阶
5.  比较次数和交换次数
6.  排序算法的内存消耗
7.  原地排序：空间复杂度o(1)的排序算法
8.  排序算法的稳定性
9.  稳定性指的是：如果待排序的序列中存在值相同的元素，经过排序后，值相同元素之间原有的先后顺序不变
10. 有序度：数组中具有有序关系的元素对的个数
11. ![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5891idj30ng0cijs7.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}
12. 满有序度：完全有序的数组的有序元素对的个数。n(n-1)/2
13. 逆序度：逆序度和有序度相反。逆序度 = 满有序度-有序度
14. 冒泡排序
15. ![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb595u94j30oc0hywg5.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}
16. 冒泡排序的思想：比较相邻的俩个元素，看是否满足大小关系，不满足就交换。一次冒泡会让至少一个元素移动到他应该在的位置。重复n次就完成了n各元素的排序工作
17. 冒泡排序是原地排序
18. 冒泡排序是稳定性排序。
19. 冒泡排序的最好时间复杂度为o(1)，
    最坏时间复杂度为o(n^2)，平均时间复杂度为o(n^2)
20. 插入排序
21. ![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb59o84cj30me0j6dhd.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}
22. 插入排序思想：将数组分为俩个部分，已排序区间和未排序区间，初始已排序区间只有一个元素那就是数组第一个元素。插入排序就是不断取出未排序元素，依次和已排序元素比较找到合适的插入位置插入数据。重复这个过程知道未排序区间为空。
23. 插入排序是原地排序
24. 插入排序是稳定排序
25. 插入排序的最好时间复杂度为o(n)，
    最坏时间复杂度为o(n^2)，平均时间复杂度为o(n^2)
26. 选择排序
27. ![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5a44vzj30gq0l60um.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}
28. 选择排序思想：选择排序也将数组分为"已排序区间"和"未排序区间"，但是选择排序每次会从未排序区间选择最小值插入到已排序区间末尾。
29. 选择排序是原地排序
30. 选择排序是一种不稳定的排序
31. 选择排序的最好时间复杂度为o(n^2)，最坏时间复杂度为o(n^2)，平均时间复杂度为o(n^2)

5、归并排序

1）思想：将待排序数组递归的从中间分成俩部分，分别进行排序，再将排序好的部分和在一起。

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5b2tfuj30ua0o0dio.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

2）归并排序是稳定排序，因为相同元素在合并的时候前后关系没变

3）不论最好最坏情况，归并排序的时间复杂度都是o(nlogn)

4）归并排序不是原地排序，空间复杂度为o(n)。

6、快速排序

1）思想：选择数组中人一个元素作为分区点，数组中大于此分区点的放到分区点的右边，小于该分区点的放到

分区点的左边。分别递归数组左边和右边部分。

2）快排是一种原地的不稳定排序

3）快排最好情况的时间复杂度为o(nlogn)，最坏情况时间复杂度为o(n^2)

4）归并排序和快速排序的区别

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5c0egsj30u60iuacf.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

归并排序的处理过程是由下至上，先处理子问题然后再合并。快速排序的处理过程是由上至下，先分区然后再

处理子问题。

7、桶排序

1）思想：将待排序的数据分到几个有序的桶里，每个桶里的数据再利用排序算法单独排序。桶内排序完成之

后，再把桶里的数据按照顺序依次取出。

2）什么场景下适用桶排序：

a、要排序的数据能够很容易的划分成几个桶

b、数据在几个桶之间分布要比较均匀(如果划分后桶内数据并不均匀(有的多有的少)，多者可以继续划分)

c、外部排序（排序数据存储在外部磁盘中）

8、计数排序

1）思想：将待排序数据划分为k个桶，但是桶内数据值是相同的。

2）实现原理图解

待排序数组：2、5、3、0、2、3、0、3

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5d0mn7j30u607u3z5.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5dhup6j30u606ot94.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

3、遍历原始数组，当扫描到3时，从数组c中取出下标为3的元素也就是7，7就代表3这个元素是排序好的

数组的第七个元素，然后将其放入排序好数组的下标为6的位置，此时c中下标为3的元素减一。以此类

推直到遍历完原始数组中所有的元素

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5ecrfdj30u013zdmz.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

3）桶排序的适用场景：

a、待排序数据计数范围不大

b、只能给非负整数排序（如果数据为其他类型，在不改变大小的情况下，可以转换为非负数）

9、基数排序

1）思想：数据按位采用稳定排序，先排序低位再排序高位，直到排完所有位。

2）实现原理图解：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5fdg2cj30sw0ckjsd.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

注意：每一位的排序必须采用稳定排序。可以采用上述的桶排序或计数排序，这样时间复杂度可以控制在o(n)

3）基数排序的适用场景：

a、需要能分割出独立的位来进行排序，而且位之间有递进关系

b、每一位的数据范围不能太大，要使用进行线性排序（桶排序和计数排序）来进行排序

### 十、二分查找 

1、思想：二分查找是针对有序的数据集合，每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一

半。直到找到要查找的元素或者区间缩小为0.

2、二分查找的时间复杂度为o(logn)

3、二分查找的适用场景：

1）二分查找依赖数组，因为要利用数组的随机读写能力

2）二分查找针对的是有序数据

3）数据量太小不适合二分查找，但是如果数据之间的比较操作比较耗时还是推荐用二分查找

4）数据量太大也不适合二分查找，因为依赖数组，而数组需要的连续的存储空间。太大的数据量申请连续的存

储空间可能失败

5）二分查找不适合动态变化的数据集合，因为动态变化的数据集合如果要使用二分查找，得排序，频繁排序会

造成新能下降

4、四种二分查找的变形问题

1）查找第一个等于给定值的元素

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
// a = { 1,3,4,5,6,8,8,8,11,18 }

public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {  // 处理a[mid] == value的情况
      if ((mid == 0) || (a[mid - 1] != value)) return mid;
      else high = mid - 1;
    }
  }
  return -1;
}
```

2）查找最后一个值等于给定值的元素

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
// a = { 1,3,4,5,6,8,8,8,11,18 }
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {  // 处理a[mid] == value的情况
      if ((mid == n-1) || (a[mid + 1] != value)) return mid;
      else low = mid + 1;
    }
  }
  return -1;
}
```

3）查找第一个大于等于给定值的元素

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
// a = { 1,3,4,5,6,8,8,8,11,18 }
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] >= value) {
      if ((mid == 0) || (a[mid - 1] < value)) return mid;
      else high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } 
  }
  return -1;
}
```

4）查找最后一个小于等于给定值的元素

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
// a = { 1,3,4,5,6,8,8,8,11,18 }
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else(a[mid] <= value) {
      if ((mid == n-1) || (a[mid + 1] > value)) return mid;
      else low = mid + 1;
    }
  }
  return -1;
}
```

### 十一、跳表

1、定义：链表加多级索引的结构就叫跳表

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5fpuxaj30t60f8aba.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

注：加的索引层越多，查询效率越高，上图是俩个元素节点直接建立一个索引节点，还可以是隔多个节点建立一

个索引节点。

2、跳表查询，插入、删除的时间复杂度为O(logn)，空间复杂度为o(n)，采用的是空间换时间的思路。

跳表插入：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5g7qf2j30tq0judhd.jpg)

3、跳表的动态更新

跳表的动态插入和删除元素不仅需要在原始列表上插入和删除，同时也需要维护索引层的更新删除，如果不的话

就会出现下图所示的情况

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5jyumwj30le0b03yz.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

一般通过随机函数来维护索引和原始列表的稳定，随机函数的选择很讲究。

随机函数如何维持稳定：

为了维持稳定，我们一般在原始列表上插入或删除数据，也要在索引层插入或删除数据，我们通过随机函数，

来决定在插入或删除原始列表时在那些索引层插入或删除。例如随机函数生成k，则我们在1到k层索引上去插入

和删除，如下图

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5keoukj30tw0j2q4l.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

4、跳表的应用

1） redis的有序集合使用跳表实现。

问：redis为什么不使用红黑树来实现有序集合呢？

答：redis对有序集合的操作主要有，插入、删除、查找、按区间查找、输出有序序列这几个操作，红黑树也能快

速的完成对元素的插入，删除，和查找，但是在按范围查找的效率上没有跳表高。

### 十二、散列表

1、思想来源：散列表用的是数组的按照下标随机访问的特性，所以没有数组就没有散列表。

2、关键概念

Key：标志一个对象

散列函数：把key变为数组下标的方法

散列值：散列函数计算后得到的值

3、散列函数

散列函数设计的基本要求：

1）散列函数计算得到的散列值是一个非负整数

2）如果key1 = key2，那hash(key1) = hash(key2)

3）如果key1 != key2 那hash(key1) != hash(key2)

4、散列冲突的解决办法

1）开放寻址法

思想：如果出现了散列冲突，就重新探测一个新位置，将其插入

探测方法：

a、线性探测：如果散列值的位置被占用，则沿着数组下标依次查找，直到找到一个空闲位置

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5nc907j30u80gc3zw.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

b、二次探测：如果散列值的位置被占用，则沿着数组下标的二次方依次查找，直到找到一个空闲位置

c、双重散列：使用一组散列函数，先使用第一个散列函数，如果冲突换第二个，依次类推直到找到空闲位

置

装载因子：

散列装载因子 = 填入表中的元素个数 / 散列表的长度

装载银子越大，说明空闲位置越少。

缺点：数据越多，冲突越多，性能下降。

2）链表法

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5o9vsoj30u00gcjsf.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

5、设计工业级别的散列表

1）散列函数的设计

a、不能太复杂，太复杂了会消耗很多的计算时间影响性能。

b、散列函数生成的散列值要尽可能的随机并且均匀分布，这样才能较少散列冲突

2）避免装载因子过大

a、原因：装载因子过大代表散列表中的数据越多，查询性能会收到影响，因此要避免装载因子过大。

b、方法：重新申请一个更大的散列表，将数据搬移到新散列表，也就是对散列表进行扩容。（数据搬移注

意：1、数据搬移需要通过散列函数重新计算旧表数据在新表的存储位置，2、装载因子的阈值设置

要虑时空复杂度）

3）如何避免低效扩容

a、说明：当装载因子超过阈值需要扩容时，如果旧表中数据量较大则数据搬移操作会比较耗时，这样就形成

了比较低效的扩容操作。

b、解决方法：扩容时先申请新表，并不搬移数据，将搬移行为分配到每次插入操作的过程中即向新表中插入

数据时再搬移部分数据到新表中，如果是查询操作的话，先到新表中查询，如果新表中不存在

查询数据，再到旧表查询。

4）如何选择冲突的解决方法

当数据量比较小，装载因子小于1的情况下，适合使用开放寻址法，基于链表的散列冲突处理方法比较适合存

储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树

代替链表

6、为什么散列表经常和列表一起使用

链表可以弥补散列表的顺序遍历的不足，散列表可以弥补链表查询性能的不足。

举例：

1）LRU缓存淘汰策略，

LRU设计到三个操作，向缓存添加，删除，查找，这三个操作都需要涉及到查找操作，散列表和链表结

合可以将这三个操作的时间复杂度都降为o(1)

2）redis的有序集合

redis有序集合涉及到的操作：

添加一个成员对象；

按照键值来删除一个成员对象；

按照键值来查找一个成员对象；

按照分值区间查找数据，比如查找积分在 [100, 356] 之间的成员对象；

按照分值从小到大排序成员变量；

其中区间和排序操作用链表实现，添加、删除、和查找、利用了散列表的高性能。

3）java的LinkedHashMap

LinkedHashMap可以实现按照插入顺序遍历数据，这样的实现就是采用了链表，其他操作采用散列表完

成

### 十三、哈希算法 
1、什么叫哈希算法

将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法

2、优秀的哈希算法需满足一下要求

1）从哈希值不能反向推导出数据

2）对输入数据非常敏感，哪怕原始数据只修改了一个bit，最后得出的哈希值也不相同

3）散列冲突的概率很小，对于不同的原始数据，哈希值相同的概率非常小。

4）哈希算法的执行效率要尽可能的高，针对较长的文本，也能快速计算出哈希值

3、哈希算法的应用

1）安全加密

2）唯一标识

3）数据校验

哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，利用这个特点，对网络传输的

数据进行哈希值校验，防止传输出错。

4）负载均衡：一个会话粘滞（session sticky）的负载均衡算法

我们可以通过哈希算法，对客户端 IP 地址或者会话 ID
计算哈希值，将取得的哈希值与服务器列表的大小进

行取模运算，最终得到的值就是应该被路由到的服务器编号。
这样，我们就可以把同一个 IP 过来的所有请

求，都路由到同一个后端服务器上。

5）数据分片

MapReduce算法，通过对大数据进行分片，对每一条数据进行哈希，然后对服务器列表取模，就能将该条数

据分配到对应的服务器上进行处理

6）分布式存储

一致性哈希算法

### 十四、树 

1、树的相关定义

1）节点的高度 = 叶子节点到当前节点的最长路径

2）节点的深度 = 根节点到到当前节点的最长路径

3）节点的层数 = 节点的深度+1

4）树的高度 = 根节点的高度

5）满二叉树：叶子节点全部在最底层，除叶子节点外，每个节点都有左右俩个子几点

6）完全二叉树：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节

点个数都要达到最大。

2、如何表示一颗树

1）基于指针的链式存储法

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5oozplj30qq0h2t9e.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

2）基于数据的顺序存储法

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5pkfz5j30rc0de74r.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

说明：如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i
的位置存储的就是左子节点，下标为 2 * i + 1

的位置存储的就是右子节点，通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便

计算子节点，根节点会存储在下标为 1
的位置），这样就可以通过下标计算，把整棵树都串起来。

注意：如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式（如图），非完全二叉

树如果用数组的方式存储的话，会浪费很多空间，如下图。

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5q3153j30p20d0t95.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

3、二叉树的遍历

1）前序遍历

遍历顺序：中，左，右

递推公式：preOrder(r) = print
r->preOrder(r->left)->preOrder(r->right)

2）中序遍历

遍历顺序：左，中，右

递推公式：inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

3）后序遍历

遍历顺序：左，右，中

递推公式：postOrder(r) =
postOrder(r->left)->postOrder(r->right)->print r

4、二叉查找数

1）定义：二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而

右子树节点的值都大于这个节点的值

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5qy37wj30so0ccq3d.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

2）二叉查找数的操作

a、查找操作

查找过程：给定查找key，先由根节点开始，如果给定key=根节点则返回，如果key小于根节点，则在根节

点的左子树递归查找，如果key>根节点，则在根节点的右子树递归查找。

b、插入操作

插入过程：由根开始，比较插入数据和根节点，如果插入数据大于根节点且右子树为空，则将新数据直接插

到右子节点的位置，如果不为空，则递归遍历右子树寻找插入位置。如果插入数据小于根节点且

左子树为空，则将新数据插入左子几点位置，如果不为空，则递归遍历左子树寻找插入位置。

c、删除操作

第一种：如果要删除的节点是叶子节点，则直接将删除节点的父节点指向删除节点的指针改为null，如果要

删除的节点有一个子节点，则直接将要"删除节点"的"父节点"的"指向删除节点的指针"指向"删除

节点的子节点"。如果要删除指针由两个子节点，我们需要找到这个节点右子树中的最小节点，把

它替换到要删除节点上。然后再删除这个最小节点。

第二种：不真正删除节点，只是将要删除的节点标记为"已删除"

d、其他操作：查找最大、最小节点，前驱节点，后继节点。

e、中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度为o(n)

3）支持重复数据的二叉查找树

a、二叉查找树的节点不仅会存储一个数据，可以通过一个链表或者支持扩容的数组，把相同数据都存储在同

一个节点上，类似于散列表思想。

b、在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据

放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。当要查找数据的

时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停

止。这样就可以把键值等于要查找值的所有节点都找出来。对于删除操作，我们也需要先查找到每个要删

除的节点，然后再按前面讲的删除操作的方法，依次删除

4）二叉查找树的时间复杂度分析

二叉树的时间复杂度在
[o(logn)，o(n)]范围内，平衡二叉查找树的时间复杂度为o(logn)

5、红黑树

1）平衡二叉树：

a、概念：二叉树中任意一个节点的左右子树的高度差不能大于1

2）平衡二叉查找树（AVL)：既满足平衡二叉树又满足二叉查找树的特点。

a、由来：为了解决普通二叉查找树在频繁的插入，删除等动态更新的情况下，出现时间复杂度退化的问题。

b、平衡的意思其实就是让整棵树看起来比较对称，不要出现左右极为不对称的情况。

c、红黑树是平衡二叉查找树的一种

3）红黑树

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5tb476j30f705xq2y.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

A、定义：

a、根节点一定是黑色

b、每个红色节点的两个子节点一定是黑色

c、从当前节点到该节点可达的叶子节点的所有路径，包含相同数目的黑色节点。

d、每个叶子节点都是黑色的空节点，也就是说叶子节点不存储数据。

B、红黑树并不是严格的平衡二叉查找树，它是近似平衡。也叫黑色完美平衡，即每个节点的左子树和右子树

的黑色层数是相同的。 算法复杂度为O(log2n)

c、使用场景：动态插入、删除、查找数据的场景

d、红黑树可以通过左旋右旋+改变颜色自动的维持红黑树的平很行定义

e、红黑树的叶子节点为空的原因是为了抽象出方便的规则来进行旋转算法，类似于列表加一个空的哨兵节点

的思想。

f、红黑树的自平衡过程：不论删除和插入，红黑树的自平衡调整都是自底向上的。

插入：

插入节点一定是红色，如果插入是黑色，那么被插入的子树的黑色数目就会增多，就必须维持平衡，而如

果插入的是红色，就可能不用维持平衡。

插入大致分为两步：寻找插入位置，找到后自平衡。自平衡调整情况如下：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5ugyr5j31jx0u0gpl.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

注意：p代表父节点，s代表叔叔节点，i代表插入节点，pp代表祖父节点。

删除：

删除操作也大致分为三步：查找删除节点，删除后找替代节点补存到当前位置，然后自平衡

如何替换删除节点：

若删除节点无子节点则直接删除，无需替换

若删除节点有一个子节点，则用子节点替换。

若删除节点有俩个子节点，则用后继节点（大于删除节点的最小节点）替换

删除后自平衡策略：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5vqfoij31940u0tbv.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

4）动态数据结构：支持动态的插入、删除、查找、而且效率都很高的数据结构。

6、B树和B+树

### 十五、堆 {#十五堆 style="line-height: 160%; box-sizing: content-box; font-weight: 700; font-size: 27px; color: #333;"}

1、堆的定义

1）堆是一个完全二叉树

2）堆中的每个节点都必须大于等于（或小于等于）其子树中每个节点的值

2、如何实现堆

1）堆支持哪些操作

a、插入（时间复杂度为o(logn))

插入元素分为两步：在数组末尾插入元素，然后进行堆化也就是调整数据，符合堆的定义。

堆化分为自上向下和自下向上两种

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5w4rm0j30tk0jgdhk.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

b、删除（删除一般是删除对顶元素） （时间复杂度为o(logn))

删除元素也分为两步：

第一步：我们把最后一个节点放到对顶

第二部：堆化（这里是从上往下堆化）

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5x2q0vj30tk0kcgnk.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

2）如何存储堆

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5y23psj30h00dwdg1.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

说明：因为堆本质上是一个完全二叉树，因此最好使用数组来存储，根节点存储在数组索引为1的位置上，数

组中下标为i的节点的左子节点就是下标为2*i的节点，右子节点就是下标为2*i+1的节点。

3）如何用堆排序

堆排序是原地排序且时间复杂度为o(nlogn)

堆排序的步骤：

a、建堆（建堆的时间复杂度为o(n))

第一种思路：

利用插入思想建堆，插入然后堆化，这种是从下向上的堆化

第二种思路：

插入所有数据，然后从第一个非叶子节点开始，从下向上堆化。

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5yg8ejj30r40kuwfm.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb5zx4snj30t20lqwg7.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

说明：如上图，8是第一个非叶子几点，也就是n/2节点，我们对下标从 2n​ 开始到
1 的数据进行堆化，

实际上，对于完全二叉树来说，下标从 2n​+1 到 n 的节点都是叶子节点。

b、排序（排序的时间复杂度为o(logn)

1、将对顶元素和最后一个元素替换，

2、然后对剩下的n-1个元素进行堆化

3、重复1、2步骤

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb60trinj30rm0ia0u7.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

4）快速排序和堆排序时间复杂度都为o(nlogn),为什么实际项目中快排会更好

a、堆排序数据访问的方式没有快速排序友好，快排是顺序访问数据，堆排是跳着访问，对cpu缓存不友好

b、堆排在建堆的时候会打乱原有的顺序，如果数据原本有一定的顺序，堆排会对这个顺序进行破坏。

3、堆的应用

1）优先级队列

一个堆就可以看做是一个优先级队列，往有衔接队列里插入一个元素，就相当于往堆中插入一个元素。从优先

级队列里取一个元素就相当于取出堆定元素。

2）利用堆求top k

建立一个k大小的大顶堆，然后不断想堆中添加元素，如果添加元素大于堆定元素，则插入堆，如果小于堆顶

元素则不做任何处理。

3）求动态集合的中位数或k分位数

维护俩个堆，一个大顶堆，一个小顶堆，大顶堆存k分位前半部分数据，小顶堆存k分位后半部分数据，且小顶

堆的数据都大于大顶堆。堆顶元素就是分位值，如果再来数据，直接跟大顶堆堆顶元素比较，如果小于大顶堆

元素，则插入大顶堆，小于则插入小顶堆。我们可以从一个堆中不停地将堆顶元素移动到另一个堆来调整由于

数据插入造成的数据不满足大顶堆和小顶堆分别存储的前后部分数据的约定。

### 十六、图 

1、图的定义

1）图是一种非线性结构，图中的元素叫做顶点，顶点之间的链接关系叫做边。顶点的度就是跟顶点相连的边的

条数。

2、图的分类

1）有向图

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb61r1mlj30gm0920sw.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

2）无向图

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb627jlcj30g607wglq.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

3）带权图

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb641ozlj30g008qjri.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

3、图的存储方式

1、邻接矩阵

本质就是一个二维数组

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb64jnbrj30se0hidh3.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

稀松图：顶点很多，边不多

优点：直观、简单。缺点：浪费空间，尤其在存储稀松图时。

2、邻接列表

类似于哈希表

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb64zgjbj30tm0aeaax.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

优点：比较节省空间，缺点：使用起来比较耗时。

可以将节点列表换成更加高效的查询结构，比如：平衡二叉树、跳表、散列表等。

3、图的搜索算法

1）广度优先

借用了队列，层层搜索。

2）深度优先

借用了回溯思想，也就是栈的思想。类似走迷宫一条路走不通走另外一条路。

### 十七、字符串匹配算法 

1、基础的字符串匹配算法

BF：暴力匹配算法。时间复杂度为o(m*n) m为匹配串的长度，n为主串的长度

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb65hf3sj30nw0kwjso.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

思想：如果模式串长度为 m，主串长度为 n，那在主串中，就会有 n-m+1
个长度为 m 的子串，我们

只需要暴力地对比这 n-m+1
个子串与模式串，就可以找出主串与模式串匹配的子串。

RK：RK算法是BF算法的升级版本，它的核心思想就是通过哈希算法对主串中的
n-m+1 个子串分别求哈希值，

然后逐个与模式串的哈希值比较大小。时间复杂度为o(n-m+1)=o(n)，这样的效率主要取决于哈希算法的

设计 。

2、高效的字符串匹配算法

BM：本质原理是在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定

不会匹配的情况，将模式串往后多滑动几位。它是对bf的改进

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb66i388j30mu0au74h.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

上图中c肯定不在abc中，因此abc可以移动到c后再开始匹配

bm实现规则：bm分别计算坏字符规则和好后缀规则移动位数，取最大。

1）坏字符规则

**先找坏字符：**模式串从后往前向前比较，第一个不匹配的字符即为坏字符，记下当前模式串中与坏字

符对应的字符的下标位 si，

**确定后移几位**：如果坏字符在模式串中存在，则查找坏字符在模式串中的位置，即为xi，不存在则xi

为-1。移动位数=si-xi，如果坏字符在模式串中多处出现我们记录最靠后的那个。

缺点：根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是
aaaaaaaaaaaaaaaa，模式串是

baaa。不但不会向后滑动模式串，还有可能倒退，好后缀规则可以弥补。

2）好后缀规则

先找好后缀，模式串从后向前比较，第一个不匹配字符之前比较过的所有字符组成的子串叫做好后

缀。

确定移动位置：1、档模式串中其他位置存在好后缀子串，模式串直接移动位置到本串中好后缀字符与

主串好后缀重合的位置。2、当模式串中其他位置不存在好后缀对应的子串时，再查找

最长的能跟模式串前缀子串匹配的后缀子串。若找到则移动模式串的位置到模式串前

缀和主串好后缀重合位置。若不包含则直接将模式串移动到主串好后缀的后边。

3.  如何选用到底是用好后缀还是坏字符来确定模式串移动的位置：
    分别计算这俩种算法需要移动的位数

取移动位数最大的。

3、KMP 算法

原理：
本质原理是在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。相对于BM，促使他滑动的机制则更为高效。

移动原理：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb68bt28j30v80mwq4a.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

说明：
从前往后第一个不能匹配的字符叫坏字符，已经匹配的那段字符串叫好前缀。匹配过程中若遇到

坏字符，则需要对模式串进行移动。具体移动位数由以下算法决定：

1）在主串坏字符之前的所有后缀子串中寻找一个子串，

2）在模式串坏字符之前的所有前缀子串中寻找一个子串，

3）这俩个子串能够完全匹配且是所有子串中长度最长的即最长匹配子串

4）模式串移动位数 = 模式串中坏字符的位置 - 最长匹配子串的长度。

如何高效寻找最长匹配子串(next数组）

4、Trie

1）定义：字典树，用来解决一组字符串集合中快速找某个字符串。也是一种多模式串匹配算法

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb68tettj30r40de0su.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

3）如何实现：首先Trie树是一颗多叉数，其次Trie应该支持两种操作，构建和查询。实际的构建过程其实就是向Trie树中插入字符串。

Trie树的节点，

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb6977noj30s407a74c.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

4）优缺点：

a、查询的时间复杂度就是字符串的长度 o(k)

b、适用通过前缀匹配字符串的场景，不适用于精确匹配的场景，精确匹配可以使用散列表和红黑树

c、字符串中包含的字符集不能太大，太大会很耗费内存空间。见TrieNode

d、要求字符串前缀重合比较多，不然消耗空间也会变大

e、Node中的指针结构对缓存不友好。

5、AC自动机

1）定义：是一种多模式串的匹配算法，也就是在一个主串中查找多个模式串。

2）优点：相较于单模式串匹配，它只需要扫描一次主串就能在主串中匹配出多个模式串。

3）AC自动机的动机：

Trie树也是一种多模式串匹配算法，也可以实现敏感词过滤，

具体步骤为：

a、将所有敏感词组织成Trie树

b、将用户输入的主串，从第一个字符开始在Tire树中匹配，当匹配到叶子节点或中途有节点不匹配，

则将主串移动一位，从第二个字符开始接着匹配。以此类推。

AC自动机和Trie树的关系就类似，KMP和BF的关系，AC自动机对Trie树的优化就是在每次不匹配时想办法

将主串的匹配开始字符向后移动几位而不是一位。因此也就是在Trie树的基础上添加了Next数组。

4）AC自动机的构建步骤

a、构建Trie树

b、在Trie树上构建失败指针（也就是next数组）

5）如何构建失败指针

a、什么是节点的失败指针：节点失败指针是一个指向其他节点的指针，等于从root遍历到当前节点所组成

的字符串，用其后缀与构建Trie树的所有的模式串的前缀进行匹配，选出最长的。然后为本节点添加一

个指针指向最长前缀所在字符串的前缀最后一个节点。这个指针就是失败指针。

如图：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb6aaavjj30n80ewq30.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

说明： 模式串为abcd， bcd, c, bc 。图中紫色的c指向红色c的就是失败指针。

b、如何为每个节点构建失败指针：

相同深度节点的失败指针只可能出现在上一层，所以可以通过上一层来推导下一层的失败节点指针。

1）root的失败指针为null，也就是指向自己

2）一个节点的失败指针已明确，则其子节点的失败指针分为两种情况:

*、当该节点的子节点
与失败指针指向的字符的子节点相同的话，则子节点的失败指针指向当前失败

指针指向的字符的子节点.

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb6b2x8ej30pi0f0mxb.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

*、当该节点的子节点与失败指针指向节点的子节点不相同, 则令q = q->fail
，也就是让失败指针上

移，再比较当前节点和q指向的字符串的子节点。循环比较直到q是root为止

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb6bkhulj30sq0fcjrm.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

*. Ac自动机构建完成如图

![](https://tva1.sinaimg.cn/large/008i3skNly1gwdb6clpkyj30ou0ey74k.jpg){style="line-height: 160%; margin: 4px 0 10px; box-sizing: border-box; vertical-align: top; max-width: 100%;"}

6）如何在AC自动机上匹配主串

在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是
b，主串是 a。

1、 如果 p 指向的节点有一个等于 b[i]的子节点 x，我们就更新 p 指向
x，这个时候我们需要通过失败指

针，检测一系列失败指针为结尾的路径是否是模式串。这一句不好理解，你可以结合代码看。处理完

之后，我们将 i 加一，继续这两个过程

2、如果 p 指向的节点没有等于
b[i]的子节点，那失败指针就派上用场了，我们让 p=p->fail，然后继续这

2 个过程。

``` {style="line-height: 160%; box-sizing: content-box; border: 0; border-radius: 0; margin: 2px 0 8px; background-color: #f5f7f8;"}
public void match(char[] text) { // text是主串
  int n = text.length;
  AcNode p = root;
  for (int i = 0; i < n; ++i) {
    int idx = text[i] - 'a';
    while (p.children[idx] == null && p != root) {
      p = p.fail; // 失败指针发挥作用的地方
    }
    p = p.children[idx];
    if (p == null) p = root; // 如果没有匹配的，从root开始重新匹配
    AcNode tmp = p;
    while (tmp != root) { // 打印出可以匹配的模式串
      if (tmp.isEndingChar == true) {
        int pos = i-tmp.length+1;
        System.out.println("匹配起始下标" + pos + "; 长度" + tmp.length);
      }
      tmp = tmp.fail;
    }
  }
}
```

十八、基本算法

1、贪心算法

1）适用问题：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据。在满足限制值的情况

下，期望值最大。每次选择当前情况下，我们选择在限制值同等共享的情况下，对期望值贡献最大的数

据。

2）缺点：如果一个问题前面的选择会影响后面的选择，则这种问题用贪心算法解未必最优

2、分治算法：

1）定义：将原问题划分为n个规模较小，并且与原问题相似的子问题，递归的解决这些子问题，然后再何合并其结果得到原问题的解。

2、回溯算法

1）描述：回溯的处理思想类似于枚举，我们一般把问题的求解过程分为多个阶段，每个阶段，我们都会到达一个岔路口，我们先随意面对一个岔路口，当发现这条路不符合期望时，就退回到上一路口，另选走法继续走。

2）用回溯算法解题的一般步骤

a、针对所有问题，明确问题的解空间

b、确定节点的扩展搜索规则

d、以深度优先的方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。
